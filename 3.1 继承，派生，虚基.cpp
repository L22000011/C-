*****
1.如果基类没有定义默认构造函数，
派生类应该声明带【形参】的构造函数
2.虚函数时可以继承的
***/*



/*继承（is-a）：    /*默认是private继承*/

具有传递性

1.被继承的类为基类（base class）（或父类），
2.通过继承关系定义的新类称为派生类（derived class）（子类）。
3.派生类不仅可以继承原来类的成员，还可以产生新的成员：
 • 增加新的数据成员；
  • 增加新的成员函数；
   • 重新定义已有成员函数；
    • 改变已有成员的访问属性
4.一个类既可以从一个基类派生，也可以从多个基类派生
5.形式：
    class 派生类名 : 继承方式 基类名
    { 派生类中的新成员 }

6.派生类：继承了成员函数（除了析构函数，构造函数）
    当定义同名的数据成员或者成员函数时会将基类的覆盖
7.派生类不能访问：（基类的私有成员和不可访问成员）

8.派生类的（构造函数）负责调用基类的构造函数
9.派生类的构造函数除初始化新增的数据成员外，
还对基类中的数据成员进行初始化
10.对基类的数据成员的初始化由基类的构造函数
完成，以避免类与类之间相互干扰
11.先执行基类的构造函数来初始化继承来的数据，再执
行派生类的构造函数。
12.对象析构时，先执行派生类析构函数，再执行由编译
器自动调用的基类的析构函数。

13.基类构造函数的参数默认值不会被派生类
继承，但由默认参数导致的多个构造函数版本
都会被派生类继承
14.如果基类的某个构造函数被声明为私有成员函
数，则不能在派生类中声明继承该构造函数
15.如果派生类使用了继承基类构造函数，编译器
就不会再为派生类生成默认构造函数
16.基类中的私有成员，不允许在派生类成员函数
中被访问，也不允许派生类的对象访问它们。

17.若是使用public继承方式，则成为派生类的公有成
员，既可以在派生类成员函数中访问，也可以被派
生类的对象访问
18.若是使用private继承方式，则只能供派生类成员
函数访问，不能被派生类的对象访问。
19.派生类可以重写基类成员函数
在派生类中通过   using 类名::成员函数名 恢复基类成员函数
*/

私有继承中，基类中所有成员函数对派生类中的对象都不可见


/*多重继承：
二义性：1.多个基类中有同名的成员，在派生类中访问同名成员时。
    2.多个基类有一个共同的基类（祖先类），在派生类中访问
祖先类的成员时。

解决：1.使用限定名来访问基类的同名成员。类型 类名::变量
     2. • 将祖先类设置为虚基类。（virtual）

*/



小结：

对于公有继承方式
　　(1) 基类成员对其对象的可见性：
　　公有成员可见，其他不可见。这里保护成员同于私有成员。
　　(2) 基类成员对派生类的可见性：
　　公有成员和保护成员可见，而私有成员不可见。这里保护成员同于公有成员。
　　(3) 基类成员对派生类对象的可见性：
　　公有成员可见，其他成员不可见。
　　所以，在公有继承时，派生类的对象可以访问基类中的公有成员；派生类的成员函数可以访问基类中的公有成员和保护成员。这里，一定要区分清楚派生类的对象和派生类中的成员函数对基类的访问是不同的。

对于私有继承方式
　　(1) 基类成员对其对象的可见性：
　　公有成员可见，其他成员不可见。
　　(2) 基类成员对派生类的可见性：
　　公有成员和保护成员是可见的，而私有成员是不可见的。
　　(3) 基类成员对派生类对象的可见性：
　　所有成员都是不可见的。
　　所以，在私有继承时，基类的成员只能由直接派生类访问，而无法再往下继承。
   （4）基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问

对于保护继承方式
　　(1) 基类成员对其对象的可见性：
　　公有成员可见，其他成员不可见。
　　(2) 基类成员对派生类的可见性：
　　公有成员和保护成员是可见的，而私有成员是不可见的。
　　(3) 基类成员对派生类对象的可见性：
　　所有成员都是不可见的。
  （4）基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问

