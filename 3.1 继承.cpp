/*继承（is-a）：
1.被继承的类为基类（base class）（或父类），
2.通过继承关系定义的新类称为派生类（derived class）（子类）。
3.派生类不仅可以继承原来类的成员，还可以产生新的成员：
 • 增加新的数据成员；
  • 增加新的成员函数；
   • 重新定义已有成员函数；
    • 改变已有成员的访问属性
4.一个类既可以从一个基类派生，也可以从多个基类派生
5.形式：
    class 派生类名 : 继承方式 基类名
    { 派生类中的新成员 }

6.派生类：继承了成员函数（除了析构函数，构造函数）
    当定义同名的数据成员或者成员函数时会将基类的覆盖
7.派生类不能访问：（基类的私有成员和不可访问成员）

8.派生类的（构造函数）负责调用基类的构造函数
9.派生类的构造函数除初始化新增的数据成员外，
还对基类中的数据成员进行初始化
10.对基类的数据成员的初始化由基类的构造函数
完成，以避免类与类之间相互干扰
11.先执行基类的构造函数来初始化继承来的数据，再执
行派生类的构造函数。
12.对象析构时，先执行派生类析构函数，再执行由编译
器自动调用的基类的析构函数。

13.基类构造函数的参数默认值不会被派生类
继承，但由默认参数导致的多个构造函数版本
都会被派生类继承
14.如果基类的某个构造函数被声明为私有成员函
数，则不能在派生类中声明继承该构造函数
15.如果派生类使用了继承基类构造函数，编译器
就不会再为派生类生成默认构造函数
16.基类中的私有成员，不允许在派生类成员函数
中被访问，也不允许派生类的对象访问它们。

17.若是使用public继承方式，则成为派生类的公有成
员，既可以在派生类成员函数中访问，也可以被派
生类的对象访问
18.若是使用private继承方式，则只能供派生类成员
函数访问，不能被派生类的对象访问。
19.派生类可以重写基类成员函数
在派生类中通过using 类名::成员函数名 恢复基类成员函数
*/

私有继承中，基类中所有成员函数对派生类中的对象都不可见


/*多重继承：
二义性：1.多个基类中有同名的成员，在派生类中访问同名成员时。
    2.多个基类有一个共同的基类（祖先类），在派生类中访问
祖先类的成员时。

解决：1.使用限定名来访问基类的同名成员。类型 类名::变量
     2. • 将祖先类设置为虚基类。（virtual）

*/
