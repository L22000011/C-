        第六章
        
1．C++中所谓多态性是指（  b ）。
A. 不同的对象调用不同名称的函数
B. 不同的对象调用相同名称的函数
C. 一个对象调用不同名称的函数
D. 一个对象调用不同名称的对象


2．有关多态性说法不正确的是（c  ）。
A. C++语言的多态性分为编译时的多态性和运行时的多态性
B. 编译时的多态性可通过函数重载实现
C. 运行时的多态性可通过函数重载实现
D. 实现运行时多态性的机制称为动态多态性

3．以下（ a ）是正确的纯虚函数定义。
A. virtual void tt()=0 
 /*在成员函数的形参后面写上=0，则成员函数为纯虚函数。
纯虚函数声明：
virtual 函数类型 函数名 （参数表列） = 0；*/
B. void tt(int)=0
C. virtual void tt(int)
D. virtual void tt(int){}

4．C++类体系中，能被派生类继承的是（  b  ）。
A．构造函数　　　B．虚函数　　　C．析构函数　　　D．友元函数

5．以下关于抽象类的说法正确的是（   c）。
A. 至少有一个虚函数的类就称为抽象类
B. 抽象类可以被实例化  即不能创建一个对象
C. 抽象类至少有一个纯虚函数
D. 抽象类不能被继承（错，可以继承） 抽象类只能作为基类使用（对）

6．对于下面两个类的描述正确的为（  a ）。
   
A.  Animal为抽象类，Brid也为抽象类
B.  Animal为抽象类，所有的成员函数均为纯虚函数
C.  Brid类不包含纯虚函数，因此不是抽象类
D.  若有基类指针Animal* p= new Fish(“goldenfish”); 执行语句p->sleep();
则调用Animal::sleep()
7.	关于派生类，以下理解正确的为（   b ）。
A.	派生类从基类继承全部数据成员和部分成员函数
B.	派生类是对基类的扩展，可以新增数据成员与成员函数
C.	派生类中只能使用基类的成员函数，不能对其进行重新定义
D.	派生类可以使用基类的成员，基类也可以使用派生类成员



模板基础概念练习题
1、 下列对模板的声明,正确的是____c_____。 
 A)template<T> 
 B)template<class T1,T2> 
 C)template<class T1,class T2> 
 D)template<C1ass T1,class T2> 


2、 类模板的模板参数_______d__。 
 A)只可作为数据成员的类型 
 B)只可作为成员函数的返回类型 
 C)只可作为成员函数的参数类型 
 D)以上三者皆可 


3、 类模板的使用实际上是将类模板实例化成一个具体的__ A
 A)类 
 B)对象 
 C)函数 
 D)子类
建立模板的实例化过程：模板类，对象


4、 关于函数模板，描述错误的是（  a ）
A) 函数模板必须由程序员实例化为可执行的函数模板   类模板
B) 函数模板的实例化由编译器实现
C) 一个类定义中，只要有一个函数模板，则这个类是类模板
D) 类模板的成员函数都是函数模板，类模板实例化后，成员函数也随之实例化


5、 假设有函数模板定义如下：
template <class T>
void Max(T a, T b, T &c)
{ c=a+b; }
下列选项正确的是（ a  ）（两个答案）
A)  float x,y; float z;  Max(x,y,z);
B)  int x; float y,z; Max(x,y,z);
C)  int x,y; float z; Max(x,y,z);
D)  float x; int y, z; Max(x,y,z);



